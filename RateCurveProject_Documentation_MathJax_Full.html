<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="utf-8">
  <title>RateCurveProject – Documentation Quantitative</title>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 2rem auto;
      max-width: 960px;
      line-height: 1.6;
      color: #111827;
      background: #f9fafb;
    }

    h1,
    h2,
    h3 {
      color: #111827;
    }

    h1 {
      text-align: center;
      margin-bottom: 0.2rem;
    }

    h1+p.subtitle {
      text-align: center;
      color: #4b5563;
      margin-top: 0;
      margin-bottom: 2rem;
      font-size: 0.95rem;
    }

    code {
      background: #e5e7eb;
      padding: 0.1rem 0.3rem;
      border-radius: 4px;
      font-size: 0.9em;
    }

    pre {
      background: #111827;
      color: #e5e7eb;
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 0.9em;
    }

    pre code {
      background: none;
      padding: 0;
    }

    hr {
      border: none;
      border-top: 1px solid #e5e7eb;
      margin: 2rem 0;
    }

    .section {
      background: #ffffff;
      padding: 1.5rem 1.75rem;
      border-radius: 12px;
      margin-bottom: 1.5rem;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.06);
    }

    ul {
      padding-left: 1.4rem;
    }

    li {
      margin-bottom: 0.2rem;
    }

    .formula-inline {
      font-family: "Latin Modern Math", "STIX Two Math", "Times New Roman", serif;
      font-size: 1.02em;
    }
  </style>
</head>

<body>

  <h1>Projet « RateCurveProject »</h1>
  <p class="subtitle">Construction et lissage de courbes de taux multi-méthodes</p>

  <div class="section">
    <h2>1. Objectif du projet</h2>

    <p>
      Le projet <strong>RateCurveProject</strong> implémente une chaîne complète de construction de courbes de taux
      (zéro-coupon) à partir de données d'obligations d"états (on a essayé avec des swaps et dépots mais pas de
      données).

    <p>
      Une fois la courbe zéro-coupon bootstrappée, le projet applique plusieurs
      <strong>méthodes d’interpolation et de lissage</strong> pour obtenir une structure de taux continue, puis calcule
      un
      ensemble de <strong>métriques de courbe</strong> (taux zéro, facteurs d’actualisation, forwards instantanés,
      pente,
      convexité) et génère des visualisations statiques (PNG) et interactives (HTML/Plotly).
    </p>

    <p>
      L’ensemble est écrit en <strong>C# / .NET</strong> et structuré en modules fortement typés, avec une attention
      particulière à&nbsp;:
    </p>

    <ul>
      <li>la séparation des responsabilités (chargement des données, moteur de calcul, visualisation, export),</li>
      <li>la qualité visuelle (courbes annotées, exports HTML multi-graphiques),</li>
      <li>la robustesse numérique (algorithmes de bootstrap, interpolation monotone, Smith–Wilson).</li>
    </ul>
  </div>

  <div class="section">
    <h2>2. Architecture globale</h2>

    <p>Le projet est organisé en plusieurs namespaces&nbsp;:</p>

    <ul>
      <li><code>RateCurveProject.Data</code> &nbsp;: chargement des instruments de marché (Excel) et calcul des
        rendements obligataires.</li>
      <li><code>RateCurveProject.Models</code> &nbsp;: représentation de la courbe (<code>Curve</code>,
        <code>CurvePoint</code>) et stratégies d’interpolation (<code>IInterpolator</code> + implémentations).
      </li>
      <li><code>RateCurveProject.Engine</code> &nbsp;: bootstrap de la courbe zéro-coupon et analyse (métriques
        dérivées).</li>
      <li><code>RateCurveProject.UI</code> &nbsp;: génération de graphiques PNG via ScottPlot.</li>
      <li><code>RateCurveProject.Output</code> &nbsp;: exports CSV et HTML/Plotly de haute qualité.</li>
      <li><code>RateCurveProject.Tests</code> &nbsp;: tests unitaires (interpolation, analyse, exports, cohérence de la
        courbe).</li>
    </ul>

    <p>Le point d’entrée <code>Program</code> orchestre le pipeline complet&nbsp;:</p>

    <ol>
      <li>Résolution du répertoire racine du projet (<code>FindProjectRoot</code>).</li>
      <li>Chargement des instruments via <code>MarketDataLoader</code> (fichier Excel par pays).</li>
      <li>Affichage des instruments bruts dans la console (tableau formaté <code>ConsoleTables</code>).</li>
      <li>Bootstrap des zéro-taux via <code>Bootstrapper</code>.</li>
      <li>Construction de la courbe <code>Curve</code> avec différentes méthodes d’interpolation&nbsp;:
        <ul>
          <li><code>LinearInterpolator</code></li>
          <li><code>CubicSplineInterpolator</code></li>
          <li><code>HaganWestInterpolator</code></li>
          <li><code>SmithWilsonInterpolator</code></li>
        </ul>
      </li>
      <li>Analyse de la courbe via <code>CurveAnalyzer</code>.</li>
      <li>Export CSV + HTML via <code>ExportManager</code>.</li>
      <li>Visualisation PNG + HTML interactifs via <code>CurvePlotter</code>.</li>
    </ol>

    <pre><code>OutputRuns/
  France/
    Linear/
      curve_plot_Linear.png
      forward_plot_Linear.png
      courbe_zero_interactive_Linear.html
      ...
    HaganWest/
    SmithWilson/
  US/
    ...
</code></pre>
  </div>

  <div class="section">
    <h2>3. Données de marché et pré-traitement (<code>RateCurveProject.Data</code>)</h2>

    <h3>3.1 Représentation des instruments</h3>

    <pre><code>public enum InstrumentType
{
    Deposit,
    SWAP,
    BOND
}

public class MarketInstrument
{
    public InstrumentType Type { get; set; }
    public double MaturityYears { get; set; }
    public double Rate { get; set; }       // taux du dépôt/swap, ou yield de l’obligation
    public double Coupon { get; set; }     // coupon en %
    public int FixedFreq { get; set; }     // fréquence de paiement fixe (1 = annuel, 0 = zéro-coupon)
    public double Price { get; set; }      // prix en fraction du nominal
}
</code></pre>

    <p>
      Les maturités sont exprimées en années fractionnelles, ce qui facilite l’usage dans les formules continues.
    </p>

    <h3>3.2 Chargement depuis Excel : <code>MarketDataLoader</code></h3>

    <p><code>MarketDataLoader</code> s’appuie sur ClosedXML pour&nbsp;:</p>
    <ul>
      <li>ouvrir un classeur Excel de cotations,</li>
      <li>lire les lignes instrument par instrument (type, maturité, taux, coupon, prix),</li>
      <li>interpréter certaines obligations comme zéro-coupon via un booléen <code>treatAsZeroCoupon</code>,</li>
      <li>construire une liste de <code>MarketInstrument</code> nettoyée (tri par maturité, suppression de doublons).
      </li>
    </ul>

    <h3>3.3 Calcul de rendement obligataire : <code>BondYieldCalculator</code></h3>

    <pre><code>public static class BondYieldCalculator
{
    public static double ComputeYield(double couponPct, double maturityYears, double pricePct)
    { ... }
}
</code></pre>

    <p>Cas zéro-coupon&nbsp;:</p>

    <p class="formula-inline">
      \( y = P^{-\frac{1}{T}} - 1 \).
    </p>

    <p>Cas couponné&nbsp;: le prix est donné par</p>

    \[
    P = \sum_{k=1}^{n} \frac{c}{(1+y)^k} + \frac{1}{(1+y)^n},
    \]

    <p>et le yield \(y\) est obtenu numériquement (dichotomie robuste).</p>
  </div>

  <div class="section">
    <h2>4. Bootstrap de la courbe zéro-coupon (<code>RateCurveProject.Engine.Bootstrapper</code>)</h2>

    <pre><code>public record CurvePoint(double T, double ZeroRate);
</code></pre>

    <h3>4.1 Hypothèses</h3>

    <ul>
      <li>Nominal fixé à 1.</li>
      <li>Coupons des obligations payés à fréquence <code>FixedFreq</code>.</li>
      <li><code>MarketInstrument.Price</code> : prix en fraction du nominal.</li>
      <li><code>MarketInstrument.Rate</code> :
        <ul>
          <li>taux simple pour les dépôts,</li>
          <li>taux fixe des swaps,</li>
          <li>yield pour les obligations.</li>
        </ul>
      </li>
    </ul>

    <h3>4.2 Logique conceptuelle</h3>

    <p><strong>Dépôts (partie courte)</strong></p>

    \[
    DF(T) = \frac{1}{1 + rT},
    \qquad
    Z(T) \approx \frac{1}{T}\,\ln\!\left(\frac{1}{DF(T)}\right).
    \]

    <p><strong>Obligations à coupon (partie longue)</strong></p>

    \[
    P = \sum_i \text{coupon}_i \cdot DF(t_i) + DF(T),
    \]

    <p>d’où</p>

    \[
    DF(T) = \frac{P - A}{B},
    \qquad
    Z_{\text{bond}}(T) = -\frac{\ln DF(T)}{T}.
    \]
  </div>

  <div class="section">
    <h2>5. Représentation de la courbe (<code>RateCurveProject.Models.Curve</code>)</h2>

    <pre><code>public class Curve
{
    private readonly List&lt;CurvePoint&gt; _points;
    private readonly IInterpolator _interp;

    public Curve(IEnumerable&lt;CurvePoint&gt; points, IInterpolator interpolator)
    {
        _points = points.OrderBy(p =&gt; p.T).ToList();
        _interp = interpolator;
        _interp.Build(_points);
    }

    public double Zero(double t) =&gt; _interp.Eval(t);

    public double DF(double t) =&gt; Math.Exp(-Zero(t) * t);

    public double ForwardInstantaneous(double t, double h = 1e-4)
    {
        var p1 = DF(Math.Max(t - h, 1e-6));
        var p2 = DF(t + h);
        return -(Math.Log(p2) - Math.Log(p1)) / (2*h);
    }

    public IReadOnlyList&lt;CurvePoint&gt; RawPoints =&gt; _points;
}
</code></pre>

    <p>Conversion zéro-taux / facteur d’actualisation&nbsp;:</p>

    \[
    DF(t) = e^{-Z(t)\,t}.
    \]

    <p>Forward instantané (approximation par différences finies centrées)&nbsp;:</p>

    \[
    f(t) \approx -\frac{\ln DF(t+h) - \ln DF(t-h)}{2h}.
    \]
  </div>

  <div class="section">
    <h2>6. Méthodes d’interpolation et de lissage</h2>

    <pre><code>public interface IInterpolator
{
    void Build(IReadOnlyList&lt;CurvePoint&gt; points);
    double Eval(double t);
}
</code></pre>

    <h3>6.1 Interpolation linéaire</h3>

    \[
    Z(t) = (1-w)\,Z_a + w\,Z_b,
    \qquad
    w = \frac{t - T_a}{T_b - T_a}.
    \]

    <h3>6.2 Spline cubique naturel</h3>

    <p>On construit un spline cubique naturel \(S(t)\) tel que \(S, S', S''\) soient continus aux points de jonction
      et \(S''\) nul aux bornes.</p>

    <h3>6.3 Interpolation de type Hagan–West</h3>

    <p>On utilise un spline de Hermite monotone&nbsp;:</p>

    \[
    Z(t) = h_{00}(s)\,y_0 + h_{10}(s)\,h\,m_0 + h_{01}(s)\,y_1 + h_{11}(s)\,h\,m_1,
    \]

    avec

    \[
    s = \frac{t - T_i}{T_{i+1}-T_i}.
    \]

    <h3>6.4 Méthode de Smith–Wilson</h3>

    <p>Pour chaque pilier \((u_j, Z(u_j))\), on définit</p>

    \[
    P(u_j) = e^{-Z(u_j)\,u_j}.
    \]

    <p>La courbe Smith–Wilson est définie par</p>

    \[
    P(t) = e^{-\text{UFR}\,t} + \sum_j \xi_j\,W(t, u_j),
    \qquad
    Z(t) = -\frac{\ln P(t)}{t},
    \]

    <p>où \(W(t,u_j)\) est le noyau Smith–Wilson, \(\text{UFR}\) l’ultimate forward rate et \(\lambda\) le paramètre de
      convergence.</p>
  </div>

  <div class="section">
    <h2>7. Analyse de la courbe (<code>CurveAnalyzer</code>)</h2>

    <pre><code>public record Metric(
    double T,
    double Zero,
    double DF,
    double Forward,
    double Slope,
    double SecondDerivative
);
</code></pre>

    <p>
      Pour un grillage de maturités \(\{T_k\}\), on calcule
      \(Z(T_k)\), \(DF(T_k)\), le forward \(f(T_k)\), la pente \(Z'(T_k)\) et la convexité \(Z''(T_k)\)
      (par différences finies).
    </p>
  </div>

  <div class="section">
    <h2>8. Exports et visualisation</h2>

    <h3>8.1 Export CSV et HTML</h3>

    <ul>
      <li>CSV&nbsp;: colonnes \(T\), \(Zero\), \(DF\), \(Forward\).</li>
      <li>HTML Plotly&nbsp;: courbes interactives (zéros, DF, forwards, dérivées).</li>
    </ul>

    <h3>8.2 Visualisation ScottPlot</h3>

    <ul>
      <li>Courbe zéro-taux + discount factors.</li>
      <li>Courbe de forwards instantanés.</li>
      <li>Colorisation et légendes par méthode (Linear, CubicSpline, HaganWest, SmithWilson).</li>
    </ul>
  </div>

  <div class="section">
    <h2>9. Orchestration (<code>Program</code>)</h2>

    <p>
      Pour chaque méthode d’interpolation, le programme construit une <code>Curve</code>, calcule les métriques,
      exporte CSV/HTML et génère les PNG correspondants.
    </p>
  </div>

  <div class="section">
    <h2>10. Pistes d’extension quantitative</h2>

    <ul>
      <li>Conventions de marché complètes (day count, calendriers, business day adjustment).</li>
      <li>Courbes multi-devises / multi-courbes (OIS vs courbe de projection).</li>
      <li>Bucket sensitivities par pilier, grecs de courbe.</li>
      <li>Diagnostics visuels avancés (heatmaps de forwards, contributions instrument par instrument).</li>
    </ul>

    <p>
      Le projet <strong>RateCurveProject</strong> fournit ainsi un socle robuste de construction et d’analyse de
      courbes de taux pour des usages de pricing, de gestion du risque de taux et d’ALM.
    </p>
  </div>

</body>

</html>